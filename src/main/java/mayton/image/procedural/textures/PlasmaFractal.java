package mayton.image.procedural.textures;

import mayton.image.procedural.IProceduralTexture;
import mayton.math.IMatrix;
import org.jetbrains.annotations.NotNull;

import java.util.Map;
import java.util.Random;

import static java.lang.Math.floor;

/**
 * <h3>Plasma fractals</h3>
 * <p>
 * <p>http://www.sergemeunier.com/blog/plasma-fractals/</p>
 * <p>
 * <p>This is the first in a series of posts that I am going to do on generating fractals
 * using C#. All code was compiled using Visual Studio 2008.</p>
 * <p>
 * <p>The source code for the application, which includes all the fractals which will be
 * covered in the series is available for download here.</p>
 * <p>
 * <p>Everybody always covers the Mandelbrot as the fractal of choice, so, in doing things
 * a little differently, I decided to start with plasma fractals, and leave the Mandelbrot until later.</p>
 * <p>
 * <p>So, what is a plasma fractal exactly? A plasma fractal is generated by taking a
 * rectangle with a width x and height y. Then to each corner in the rectangle, assign a
 * random value between 0 and 1.</p>
 * <p>
 * <p>The next step is to find the midpoint of each side, and at that point, calculate the
 * average value of the two points that this point is bisecting. A midpoint is also calculated,
 * which is in the centre of the rectangle, which is the average of all four corners plus a
 * random displacement.</p>
 * <p>
 * <p>Then for each of the four rectangle bounded by the new points, repeat the process, until all the pixels have been calculated.</p>
 * <p>
 * <p>After the values have been calculated, the values can be converted to colours using any method you like. Using the raw values unaltered will create a greyscale image very well with only adjusting the value to put it in the correct range.</p>
 * <p>
 * <p>Now, in the code to do this (which can be found in Plasma.cs in the source download), first, we have a few global variables</p>
 * <p>
 * <p>The roughness is amount in which we are going to vary the value by for the midpoint.gBigSize is defined as the width plus the height of the image we are generating. FastRandom is a random number generator, which works exactly like the builtin random number generator, except that it is faster.</p>
 * <p>
 * <p>Our starting point is the Generate function that return a two-dimensional array of values where each entry in the array corresponds to an xy coordinate and the value is the calculated value, which will be converted into a colour.</p>
 * <p>
 * <p>This function sets the four initial corners, and sets the global variables, and then starts the recursion to generate the rest of the points by calling divideGrid, which is what follows next. The most import point here is that the array containing the points is passed as a reference variable to divideGrid, so that as it recurses, it can update the points accordingly.</p>
 * <p>
 * <p>If the rectangle is bigger than a pixel, then this function now calculates the average for the four edges, as well as the average of all four corners with the displacement added for the centre.</p>
 * <p>
 * <p>After this the values are rectified, so that the values stay within the bounds set, and the divideGrid function is called again for each new rectangle.</p>
 * <p>
 * <p>If the rectangle is a pixel big, then we have reached the base case, and only the centre is calculated and assigned. At this point the function does not recurse any deeper but now returns.</p>
 * <p>
 * <p>Lastly we just have rectify and displace which we have dealt with already. displace just calcualtes a random displacement based on the size of the rectangle and the roughness.</p>
 */
public class PlasmaFractal implements IProceduralTexture {

    public double gRoughness;
    public double gBigSize;
    Random rnd = new Random();

    public PlasmaFractal(int iWidth, int iHeight, double iRoughness) {
        this.iWidth = iWidth;
        this.iHeight = iHeight;
        this.iRoughness = iRoughness;
    }

    int iWidth = 0;
    int iHeight = 0;
    double iRoughness;

    double[][] Generate() {

        double c1, c2, c3, c4;
        double[][] points = new double[iWidth + 1][iHeight + 1];
        //Assign the four corners of the intial grid random color values
        //These will end up being the colors of the four corners
        c1 = rnd.nextDouble();
        c2 = rnd.nextDouble();
        c3 = rnd.nextDouble();
        c4 = rnd.nextDouble();
        gRoughness = iRoughness;
        gBigSize = iWidth + iHeight;
        divideGrid(points, 0, 0, iWidth, iHeight, c1, c2, c3, c4);
        return points;

    }

    public void divideGrid(double[][] points, double x, double y, double width, double height, double c1, double c2, double c3, double c4) {
        double edge1, edge2, edge3, edge4, middle;
        double newWidth = floor(width / 2);
        double newHeight = floor(height / 2);
        if (width > 1 || height > 1) {
            middle = ((c1 + c2 + c3 + c4) / 4) + displace(newWidth + newHeight);  //Randomly displace the midpoint!
            edge1 = ((c1 + c2) / 2);    //Calculate the edges by averaging the two corners of each edge.
            edge2 = ((c2 + c3) / 2);
            edge3 = ((c3 + c4) / 2);
            edge4 = ((c4 + c1) / 2);//
            //Make sure that the midpoint doesn't accidentally "randomly displaced" past the boundaries!
            middle = rectify(middle);
            edge1 = rectify(edge1);
            edge2 = rectify(edge2);
            edge3 = rectify(edge3);
            edge4 = rectify(edge4);
            //Do the operation over again for each of the four new grids.
            divideGrid(points, x, y, newWidth, newHeight, c1, edge1, middle, edge4);
            divideGrid(points, x + newWidth, y, width - newWidth, newHeight, edge1, c2, edge2, middle);
            divideGrid(points, x + newWidth, y + newHeight, width - newWidth, height - newHeight, middle, edge2, c3, edge3);
            divideGrid(points, x, y + newHeight, newWidth, height - newHeight, edge4, middle, edge3, c4);
        } else //This is the "base case," where each grid piece is less than the size of a pixel.
        {
            //The four corners of the grid piece will be averaged and drawn as a single pixel.
            double c = (c1 + c2 + c3 + c4) / 4;
            points[(int) (x)][(int) (y)] = c;
            if (width == 2) {
                points[(int) (x + 1)][(int) (y)] = c;
            }
            if (height == 2) {
                points[(int) (x)][(int) (y + 1)] = c;
            }
            if ((width == 2) && (height == 2)) {
                points[(int) (x + 1)][(int) (y + 1)] = c;
            }
        }
    }

    private double rectify(double iNum) {
        if (iNum < 0) {
            iNum = 0;
        } else if (iNum > 1.0) {
            iNum = 1.0;
        }
        return iNum;
    }

    private double displace(double SmallSize) {
        double Max = SmallSize / gBigSize * gRoughness;
        return (rnd.nextDouble() - 0.5) * Max;
    }

    @Override
    public @NotNull IMatrix generate(int size, @NotNull Map<String, String> parameters) {
        // TODO: Implement
        return null;
    }
}
